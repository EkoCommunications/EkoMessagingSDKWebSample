import { dispatcher, StateStore, reducer, effect } from '../src';

class TestStore extends StateStore {

  state = 0;

  @reducer 'global/reset'() {
    this.state = 0;
  }

  @reducer increment() {
    this.state++;
  }

  @reducer add({ value }) {
    this.state += value;
  }

  @effect async incrementAsync() {
    await new Promise(res => setTimeout(res, 100));
    dispatcher.testStore.increment();
  }

  @effect async addAsync({ value }) {
    await new Promise(res => setTimeout(res, 100));
    dispatcher.testStore.add({ value });
  }

}

class EmptyStore extends StateStore {
  state = 1;
}

describe('function', () => {

  let store;

  beforeEach(() => {
    store = new TestStore('testStore');
  });

  test('Reducer functions properly', () => {
    expect(store.state).toEqual(0);
    dispatcher.testStore.increment();
    expect(store.state).toEqual(1);
    dispatcher.testStore.add({ value: 10 });
    expect(store.state).toEqual(11);
  });

  test('Effect functions properly', async () => {
    expect(store.state).toEqual(0);
    dispatcher.testStore.incrementAsync();
    expect(store.state).toEqual(0);

    await new Promise(res => setTimeout(res, 200));
    expect(store.state).toEqual(1);

    dispatcher.testStore.addAsync({ value: 10 });
    expect(store.state).toEqual(1);

    await new Promise(res => setTimeout(res, 200));
    expect(store.state).toEqual(11);
  });

  test('Should handle reducers from other stores', async () => {
    dispatcher.testStore.increment();
    expect(store.state).toEqual(1);
    dispatcher.dispatch({ type: 'global/reset' });
    expect(store.state).toEqual(0);
  });

  test('Should successfully create stores without any reducers or effects', () => {
    let emptyStore = new EmptyStore('emptyStore');
    expect(emptyStore.state).toEqual(1);
  });

});
