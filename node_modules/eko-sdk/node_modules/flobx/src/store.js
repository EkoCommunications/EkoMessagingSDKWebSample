/* @flow */

import dispatcher from './dispatcher';

type ReducersType = Map<string, { [string]: any }>;

/**
 * StateStore super class
 * Works with @reducer decorator in order to simplify definition of domain stores
 */
class StateStore {
  // stores the list of reducers for this store as a map (created lazily in ./reducer)
  _reducers: ReducersType;
  _globalReducers: ReducersType;

  // stores the list of effect methods for this store as a map (created lazily in ./effect)
  _effects: ReducersType;

  // given name of this store
  _name: string;

  // used for waiting for dispatches
  dispatchToken: string;

  constructor(name?: string) {
    this._name = (name || this.constructor.name);
    this.dispatchToken = dispatcher.register(this, this._name);
  }

  // State reducer that takes in an external action, and derives a new state using
  // that new action and the existing state.
  //
  // This is a helper method that will automatically call the correct class instance
  // methods based on the action type string
  reduce(action: { type: string, [string]: any }): void {
    if (!action.type) {
      throw new Error('Action dispatched without a type');
    }

    const [ name, key ] = action.type.split('/');
    if (name === this._name && this._reducers) {
      const method = this._reducers.get(key);
      return method ? method.call(this, action) : undefined;
    } else if (this._globalReducers) {
      const method = this._globalReducers.get(action.type);
      return method ? method.call(this, action) : undefined;
    }
  }
}

export default StateStore;
