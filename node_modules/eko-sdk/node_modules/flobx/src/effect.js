/* @flow */

import StateStore from './store';

function errorMethod(): void {
  throw new Error('A effect method should not be called directly, use dispatcher shortcut');
}

/**
 * export @effect decorator
 * the effect decorator marks a method as able to handle state changes while giving off side effects.
 */
export function effect(target: StateStore, key: string, descriptor: Object): Object {
  // flow-disable-line (R: flow doesn't recognise prototopy)
  if (!(target.constructor.prototype instanceof StateStore)) {
    throw new Error('@effect decorator can only be used on a StateStore');
  }

  const mutatedDescriptor = descriptor;
  const actionType = key.replace('_', '');

  if (!target._effects) {
    target._effects = new Map();
  }
  // build the action handler based on reducer value
  target._effects.set(actionType, descriptor.value);

  // reducers should not be changed after being defined
  mutatedDescriptor.writable = false;
  // a reducer don't need to be enumerated over
  mutatedDescriptor.enumerable = false;
  // remove the actual method from class so it won't be accidentally called
  mutatedDescriptor.value = errorMethod;

  return mutatedDescriptor;
}
