/* @flow */

import { runInAction } from 'mobx';
import { Dispatcher } from 'flux';
import { isPlainObject } from 'lodash';
import StateStore from './store';

/**
 * The dispatcher is used to emit flux actions to all stores
 *
 * We are going to subclass the default flux dispatcher to make it store return values
 * from dispatches, so they can be passed to other stores via waitFor;
 */
class EkoDispatcher extends Dispatcher {

  register(store: StateStore, name: string) {
    this._addReducersAndEffects(store, name);
    return this._wrapFluxRegister(store);
  }

  // Wraps the flux native dispatch with runInAction for a performance reason to avoid mobx recomputing during
  // the dispatch but does it only in the end.
  dispatch(action) {
    runInAction(() => {
      super.dispatch(action);
    });
  }

  // wrap the given store's reducer function and register with flux dispatcher
  _wrapFluxRegister(store) {
    const callback = store.reduce.bind(store);
    return super.register(callback);
  }

  // add the reducers and effects from input store to this dispatcher as shortcut
  _addReducersAndEffects(store, name) {
    const actions = { };

    if (store._reducers) {
      store._reducers.forEach((value, key) => {
        // if reducer key is for this store, add it to this store's action list
        const keyIsThisStore = (key.indexOf('/') === -1);
        if (keyIsThisStore) {
          actions[key] = args => this._dispatch(`${name}/${key}`, args);
        }
      });
    }

    if (store._effects) {
      store._effects.forEach((value, key) => {
        actions[key] = value.bind(store);
      });
    }

    this[name] = actions;
  }

  _dispatch(type, args) {
    if (args && !isPlainObject(args)) {
      throw new Error('Dispatcher can only accept plain objects as args');
    }

    this.dispatch({
      type,
      ...args
    });
  }
}

export default new EkoDispatcher();
